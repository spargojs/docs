"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/snabbdom/build/snabbdom.cjs.js
var require_snabbdom_cjs = __commonJS({
  "node_modules/snabbdom/build/snabbdom.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createElement(tagName2, options) {
      return document.createElement(tagName2, options);
    }
    function createElementNS(namespaceURI, qualifiedName, options) {
      return document.createElementNS(namespaceURI, qualifiedName, options);
    }
    function createDocumentFragment() {
      return parseFragment(document.createDocumentFragment());
    }
    function createTextNode(text) {
      return document.createTextNode(text);
    }
    function createComment(text) {
      return document.createComment(text);
    }
    function insertBefore(parentNode2, newNode, referenceNode) {
      if (isDocumentFragment$1(parentNode2)) {
        let node = parentNode2;
        while (node && isDocumentFragment$1(node)) {
          const fragment2 = parseFragment(node);
          node = fragment2.parent;
        }
        parentNode2 = node !== null && node !== void 0 ? node : parentNode2;
      }
      if (isDocumentFragment$1(newNode)) {
        newNode = parseFragment(newNode, parentNode2);
      }
      if (referenceNode && isDocumentFragment$1(referenceNode)) {
        referenceNode = parseFragment(referenceNode).firstChildNode;
      }
      parentNode2.insertBefore(newNode, referenceNode);
    }
    function removeChild(node, child) {
      node.removeChild(child);
    }
    function appendChild(node, child) {
      if (isDocumentFragment$1(child)) {
        child = parseFragment(child, node);
      }
      node.appendChild(child);
    }
    function parentNode(node) {
      if (isDocumentFragment$1(node)) {
        while (node && isDocumentFragment$1(node)) {
          const fragment2 = parseFragment(node);
          node = fragment2.parent;
        }
        return node !== null && node !== void 0 ? node : null;
      }
      return node.parentNode;
    }
    function nextSibling(node) {
      var _a;
      if (isDocumentFragment$1(node)) {
        const fragment2 = parseFragment(node);
        const parent = parentNode(fragment2);
        if (parent && fragment2.lastChildNode) {
          const children = Array.from(parent.childNodes);
          const index = children.indexOf(fragment2.lastChildNode);
          return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;
        }
        return null;
      }
      return node.nextSibling;
    }
    function tagName(elm) {
      return elm.tagName;
    }
    function setTextContent(node, text) {
      node.textContent = text;
    }
    function getTextContent(node) {
      return node.textContent;
    }
    function isElement$1(node) {
      return node.nodeType === 1;
    }
    function isText(node) {
      return node.nodeType === 3;
    }
    function isComment(node) {
      return node.nodeType === 8;
    }
    function isDocumentFragment$1(node) {
      return node.nodeType === 11;
    }
    function parseFragment(fragmentNode, parentNode2) {
      var _a, _b, _c;
      const fragment2 = fragmentNode;
      (_a = fragment2.parent) !== null && _a !== void 0 ? _a : fragment2.parent = parentNode2 !== null && parentNode2 !== void 0 ? parentNode2 : null;
      (_b = fragment2.firstChildNode) !== null && _b !== void 0 ? _b : fragment2.firstChildNode = fragmentNode.firstChild;
      (_c = fragment2.lastChildNode) !== null && _c !== void 0 ? _c : fragment2.lastChildNode = fragmentNode.lastChild;
      return fragment2;
    }
    var htmlDomApi = {
      createElement,
      createElementNS,
      createTextNode,
      createDocumentFragment,
      createComment,
      insertBefore,
      removeChild,
      appendChild,
      parentNode,
      nextSibling,
      tagName,
      setTextContent,
      getTextContent,
      isElement: isElement$1,
      isText,
      isComment,
      isDocumentFragment: isDocumentFragment$1
    };
    function vnode(sel, data, children, text, elm) {
      const key = data === void 0 ? void 0 : data.key;
      return { sel, data, children, text, elm, key };
    }
    var array = Array.isArray;
    function primitive(s) {
      return typeof s === "string" || typeof s === "number" || s instanceof String || s instanceof Number;
    }
    function isUndef(s) {
      return s === void 0;
    }
    function isDef(s) {
      return s !== void 0;
    }
    var emptyNode = vnode("", {}, [], void 0, void 0);
    function sameVnode(vnode1, vnode2) {
      var _a, _b;
      const isSameKey = vnode1.key === vnode2.key;
      const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);
      const isSameSel = vnode1.sel === vnode2.sel;
      const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel ? typeof vnode1.text === typeof vnode2.text : true;
      return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;
    }
    function documentFragmentIsNotSupported() {
      throw new Error("The document fragment is not supported on this platform.");
    }
    function isElement(api, vnode2) {
      return api.isElement(vnode2);
    }
    function isDocumentFragment(api, vnode2) {
      return api.isDocumentFragment(vnode2);
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
      var _a;
      const map = {};
      for (let i = beginIdx; i <= endIdx; ++i) {
        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;
        if (key !== void 0) {
          map[key] = i;
        }
      }
      return map;
    }
    var hooks = [
      "create",
      "update",
      "remove",
      "destroy",
      "pre",
      "post"
    ];
    function init$1(modules, domApi, options) {
      const cbs = {
        create: [],
        update: [],
        remove: [],
        destroy: [],
        pre: [],
        post: []
      };
      const api = domApi !== void 0 ? domApi : htmlDomApi;
      for (const hook of hooks) {
        for (const module3 of modules) {
          const currentHook = module3[hook];
          if (currentHook !== void 0) {
            cbs[hook].push(currentHook);
          }
        }
      }
      function emptyNodeAt(elm) {
        const id = elm.id ? "#" + elm.id : "";
        const classes = elm.getAttribute("class");
        const c = classes ? "." + classes.split(" ").join(".") : "";
        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], void 0, elm);
      }
      function emptyDocumentFragmentAt(frag) {
        return vnode(void 0, {}, [], void 0, frag);
      }
      function createRmCb(childElm, listeners) {
        return function rmCb() {
          if (--listeners === 0) {
            const parent = api.parentNode(childElm);
            api.removeChild(parent, childElm);
          }
        };
      }
      function createElm(vnode2, insertedVnodeQueue) {
        var _a, _b, _c, _d;
        let i;
        let data = vnode2.data;
        if (data !== void 0) {
          const init3 = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;
          if (isDef(init3)) {
            init3(vnode2);
            data = vnode2.data;
          }
        }
        const children = vnode2.children;
        const sel = vnode2.sel;
        if (sel === "!") {
          if (isUndef(vnode2.text)) {
            vnode2.text = "";
          }
          vnode2.elm = api.createComment(vnode2.text);
        } else if (sel !== void 0) {
          const hashIdx = sel.indexOf("#");
          const dotIdx = sel.indexOf(".", hashIdx);
          const hash = hashIdx > 0 ? hashIdx : sel.length;
          const dot = dotIdx > 0 ? dotIdx : sel.length;
          const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
          const elm = vnode2.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag, data) : api.createElement(tag, data);
          if (hash < dot)
            elm.setAttribute("id", sel.slice(hash + 1, dot));
          if (dotIdx > 0)
            elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
          for (i = 0; i < cbs.create.length; ++i)
            cbs.create[i](emptyNode, vnode2);
          if (array(children)) {
            for (i = 0; i < children.length; ++i) {
              const ch = children[i];
              if (ch != null) {
                api.appendChild(elm, createElm(ch, insertedVnodeQueue));
              }
            }
          } else if (primitive(vnode2.text)) {
            api.appendChild(elm, api.createTextNode(vnode2.text));
          }
          const hook = vnode2.data.hook;
          if (isDef(hook)) {
            (_b = hook.create) === null || _b === void 0 ? void 0 : _b.call(hook, emptyNode, vnode2);
            if (hook.insert) {
              insertedVnodeQueue.push(vnode2);
            }
          }
        } else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode2.children) {
          vnode2.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();
          for (i = 0; i < cbs.create.length; ++i)
            cbs.create[i](emptyNode, vnode2);
          for (i = 0; i < vnode2.children.length; ++i) {
            const ch = vnode2.children[i];
            if (ch != null) {
              api.appendChild(vnode2.elm, createElm(ch, insertedVnodeQueue));
            }
          }
        } else {
          vnode2.elm = api.createTextNode(vnode2.text);
        }
        return vnode2.elm;
      }
      function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
          const ch = vnodes[startIdx];
          if (ch != null) {
            api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
          }
        }
      }
      function invokeDestroyHook(vnode2) {
        var _a, _b;
        const data = vnode2.data;
        if (data !== void 0) {
          (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, vnode2);
          for (let i = 0; i < cbs.destroy.length; ++i)
            cbs.destroy[i](vnode2);
          if (vnode2.children !== void 0) {
            for (let j = 0; j < vnode2.children.length; ++j) {
              const child = vnode2.children[j];
              if (child != null && typeof child !== "string") {
                invokeDestroyHook(child);
              }
            }
          }
        }
      }
      function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        var _a, _b;
        for (; startIdx <= endIdx; ++startIdx) {
          let listeners;
          let rm;
          const ch = vnodes[startIdx];
          if (ch != null) {
            if (isDef(ch.sel)) {
              invokeDestroyHook(ch);
              listeners = cbs.remove.length + 1;
              rm = createRmCb(ch.elm, listeners);
              for (let i = 0; i < cbs.remove.length; ++i)
                cbs.remove[i](ch, rm);
              const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;
              if (isDef(removeHook)) {
                removeHook(ch, rm);
              } else {
                rm();
              }
            } else if (ch.children) {
              invokeDestroyHook(ch);
              removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);
            } else {
              api.removeChild(parentElm, ch.elm);
            }
          }
        }
      }
      function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        let oldStartIdx = 0;
        let newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx;
        let idxInOld;
        let elmToMove;
        let before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
          if (oldStartVnode == null) {
            oldStartVnode = oldCh[++oldStartIdx];
          } else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
          } else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
          } else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldStartVnode, newStartVnode)) {
            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
          } else if (sameVnode(oldEndVnode, newEndVnode)) {
            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldStartVnode, newEndVnode)) {
            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
            api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldEndVnode, newStartVnode)) {
            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
            api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
          } else {
            if (oldKeyToIdx === void 0) {
              oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
            }
            idxInOld = oldKeyToIdx[newStartVnode.key];
            if (isUndef(idxInOld)) {
              api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
            } else {
              elmToMove = oldCh[idxInOld];
              if (elmToMove.sel !== newStartVnode.sel) {
                api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
              } else {
                patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                oldCh[idxInOld] = void 0;
                api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
              }
            }
            newStartVnode = newCh[++newStartIdx];
          }
        }
        if (newStartIdx <= newEndIdx) {
          before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
          addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        }
        if (oldStartIdx <= oldEndIdx) {
          removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
        }
      }
      function patchVnode(oldVnode, vnode2, insertedVnodeQueue) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const hook = (_a = vnode2.data) === null || _a === void 0 ? void 0 : _a.hook;
        (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 ? void 0 : _b.call(hook, oldVnode, vnode2);
        const elm = vnode2.elm = oldVnode.elm;
        if (oldVnode === vnode2)
          return;
        if (vnode2.data !== void 0 || isDef(vnode2.text) && vnode2.text !== oldVnode.text) {
          (_c = vnode2.data) !== null && _c !== void 0 ? _c : vnode2.data = {};
          (_d = oldVnode.data) !== null && _d !== void 0 ? _d : oldVnode.data = {};
          for (let i = 0; i < cbs.update.length; ++i)
            cbs.update[i](oldVnode, vnode2);
          (_g = (_f = (_e = vnode2.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode2);
        }
        const oldCh = oldVnode.children;
        const ch = vnode2.children;
        if (isUndef(vnode2.text)) {
          if (isDef(oldCh) && isDef(ch)) {
            if (oldCh !== ch)
              updateChildren(elm, oldCh, ch, insertedVnodeQueue);
          } else if (isDef(ch)) {
            if (isDef(oldVnode.text))
              api.setTextContent(elm, "");
            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
          } else if (isDef(oldCh)) {
            removeVnodes(elm, oldCh, 0, oldCh.length - 1);
          } else if (isDef(oldVnode.text)) {
            api.setTextContent(elm, "");
          }
        } else if (oldVnode.text !== vnode2.text) {
          if (isDef(oldCh)) {
            removeVnodes(elm, oldCh, 0, oldCh.length - 1);
          }
          api.setTextContent(elm, vnode2.text);
        }
        (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 ? void 0 : _h.call(hook, oldVnode, vnode2);
      }
      return function patch2(oldVnode, vnode2) {
        let i, elm, parent;
        const insertedVnodeQueue = [];
        for (i = 0; i < cbs.pre.length; ++i)
          cbs.pre[i]();
        if (isElement(api, oldVnode)) {
          oldVnode = emptyNodeAt(oldVnode);
        } else if (isDocumentFragment(api, oldVnode)) {
          oldVnode = emptyDocumentFragmentAt(oldVnode);
        }
        if (sameVnode(oldVnode, vnode2)) {
          patchVnode(oldVnode, vnode2, insertedVnodeQueue);
        } else {
          elm = oldVnode.elm;
          parent = api.parentNode(elm);
          createElm(vnode2, insertedVnodeQueue);
          if (parent !== null) {
            api.insertBefore(parent, vnode2.elm, api.nextSibling(elm));
            removeVnodes(parent, [oldVnode], 0, 0);
          }
        }
        for (i = 0; i < insertedVnodeQueue.length; ++i) {
          insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }
        for (i = 0; i < cbs.post.length; ++i)
          cbs.post[i]();
        return vnode2;
      };
    }
    function addNS(data, children, sel) {
      data.ns = "http://www.w3.org/2000/svg";
      if (sel !== "foreignObject" && children !== void 0) {
        for (let i = 0; i < children.length; ++i) {
          const child = children[i];
          if (typeof child === "string")
            continue;
          const childData = child.data;
          if (childData !== void 0) {
            addNS(childData, child.children, child.sel);
          }
        }
      }
    }
    function h3(sel, b, c) {
      let data = {};
      let children;
      let text;
      let i;
      if (c !== void 0) {
        if (b !== null) {
          data = b;
        }
        if (array(c)) {
          children = c;
        } else if (primitive(c)) {
          text = c.toString();
        } else if (c && c.sel) {
          children = [c];
        }
      } else if (b !== void 0 && b !== null) {
        if (array(b)) {
          children = b;
        } else if (primitive(b)) {
          text = b.toString();
        } else if (b && b.sel) {
          children = [b];
        } else {
          data = b;
        }
      }
      if (children !== void 0) {
        for (i = 0; i < children.length; ++i) {
          if (primitive(children[i]))
            children[i] = vnode(void 0, void 0, void 0, children[i], void 0);
        }
      }
      if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
        addNS(data, children, sel);
      }
      return vnode(sel, data, children, text, void 0);
    }
    function fragment(children) {
      let c;
      let text;
      if (array(children)) {
        c = children;
      } else if (primitive(c)) {
        text = children;
      } else if (c && c.sel) {
        c = [children];
      }
      if (c !== void 0) {
        for (let i = 0; i < c.length; ++i) {
          if (primitive(c[i]))
            c[i] = vnode(void 0, void 0, void 0, c[i], void 0);
        }
      }
      return vnode(void 0, {}, c, text, void 0);
    }
    function copyToThunk(vnode2, thunk2) {
      var _a;
      const ns = (_a = thunk2.data) === null || _a === void 0 ? void 0 : _a.ns;
      vnode2.data.fn = thunk2.data.fn;
      vnode2.data.args = thunk2.data.args;
      thunk2.data = vnode2.data;
      thunk2.children = vnode2.children;
      thunk2.text = vnode2.text;
      thunk2.elm = vnode2.elm;
      if (ns)
        addNS(thunk2.data, thunk2.children, thunk2.sel);
    }
    function init2(thunk2) {
      const cur = thunk2.data;
      const vnode2 = cur.fn(...cur.args);
      copyToThunk(vnode2, thunk2);
    }
    function prepatch(oldVnode, thunk2) {
      let i;
      const old = oldVnode.data;
      const cur = thunk2.data;
      const oldArgs = old.args;
      const args = cur.args;
      if (old.fn !== cur.fn || oldArgs.length !== args.length) {
        copyToThunk(cur.fn(...args), thunk2);
        return;
      }
      for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
          copyToThunk(cur.fn(...args), thunk2);
          return;
        }
      }
      copyToThunk(oldVnode, thunk2);
    }
    var thunk = function thunk2(sel, key, fn, args) {
      if (args === void 0) {
        args = fn;
        fn = key;
        key = void 0;
      }
      return h3(sel, {
        key,
        hook: { init: init2, prepatch },
        fn,
        args
      });
    };
    function pre(vnode2, newVnode) {
      const attachData = vnode2.data.attachData;
      newVnode.data.attachData.placeholder = attachData.placeholder;
      newVnode.data.attachData.real = attachData.real;
      vnode2.elm = vnode2.data.attachData.real;
    }
    function post(_, vnode2) {
      vnode2.elm = vnode2.data.attachData.placeholder;
    }
    function destroy(vnode2) {
      if (vnode2.elm !== void 0) {
        vnode2.elm.parentNode.removeChild(vnode2.elm);
      }
      vnode2.elm = vnode2.data.attachData.real;
    }
    function create(_, vnode2) {
      const real = vnode2.elm;
      const attachData = vnode2.data.attachData;
      const placeholder = document.createElement("span");
      vnode2.elm = placeholder;
      attachData.target.appendChild(real);
      attachData.real = real;
      attachData.placeholder = placeholder;
    }
    function attachTo(target, vnode2) {
      if (vnode2.data === void 0)
        vnode2.data = {};
      if (vnode2.data.hook === void 0)
        vnode2.data.hook = {};
      const data = vnode2.data;
      const hook = vnode2.data.hook;
      data.attachData = { target, placeholder: void 0, real: void 0 };
      hook.create = create;
      hook.prepatch = pre;
      hook.postpatch = post;
      hook.destroy = destroy;
      return vnode2;
    }
    function toVNode2(node, domApi) {
      const api = domApi !== void 0 ? domApi : htmlDomApi;
      let text;
      if (api.isElement(node)) {
        const id = node.id ? "#" + node.id : "";
        const cn = node.getAttribute("class");
        const c = cn ? "." + cn.split(" ").join(".") : "";
        const sel = api.tagName(node).toLowerCase() + id + c;
        const attrs = {};
        const dataset = {};
        const data = {};
        const children = [];
        let name;
        let i, n;
        const elmAttrs = node.attributes;
        const elmChildren = node.childNodes;
        for (i = 0, n = elmAttrs.length; i < n; i++) {
          name = elmAttrs[i].nodeName;
          if (name[0] === "d" && name[1] === "a" && name[2] === "t" && name[3] === "a" && name[4] === "-") {
            dataset[name.slice(5)] = elmAttrs[i].nodeValue || "";
          } else if (name !== "id" && name !== "class") {
            attrs[name] = elmAttrs[i].nodeValue;
          }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
          children.push(toVNode2(elmChildren[i], domApi));
        }
        if (Object.keys(attrs).length > 0)
          data.attrs = attrs;
        if (Object.keys(dataset).length > 0)
          data.dataset = dataset;
        if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
          addNS(data, children, sel);
        }
        return vnode(sel, data, children, void 0, node);
      } else if (api.isText(node)) {
        text = api.getTextContent(node);
        return vnode(void 0, void 0, void 0, text, node);
      } else if (api.isComment(node)) {
        text = api.getTextContent(node);
        return vnode("!", {}, [], text, node);
      } else {
        return vnode("", {}, [], void 0, node);
      }
    }
    var xlinkNS = "http://www.w3.org/1999/xlink";
    var xmlNS = "http://www.w3.org/XML/1998/namespace";
    var colonChar = 58;
    var xChar = 120;
    function updateAttrs(oldVnode, vnode2) {
      let key;
      const elm = vnode2.elm;
      let oldAttrs = oldVnode.data.attrs;
      let attrs = vnode2.data.attrs;
      if (!oldAttrs && !attrs)
        return;
      if (oldAttrs === attrs)
        return;
      oldAttrs = oldAttrs || {};
      attrs = attrs || {};
      for (key in attrs) {
        const cur = attrs[key];
        const old = oldAttrs[key];
        if (old !== cur) {
          if (cur === true) {
            elm.setAttribute(key, "");
          } else if (cur === false) {
            elm.removeAttribute(key);
          } else {
            if (key.charCodeAt(0) !== xChar) {
              elm.setAttribute(key, cur);
            } else if (key.charCodeAt(3) === colonChar) {
              elm.setAttributeNS(xmlNS, key, cur);
            } else if (key.charCodeAt(5) === colonChar) {
              elm.setAttributeNS(xlinkNS, key, cur);
            } else {
              elm.setAttribute(key, cur);
            }
          }
        }
      }
      for (key in oldAttrs) {
        if (!(key in attrs)) {
          elm.removeAttribute(key);
        }
      }
    }
    var attributesModule2 = {
      create: updateAttrs,
      update: updateAttrs
    };
    function updateClass(oldVnode, vnode2) {
      let cur;
      let name;
      const elm = vnode2.elm;
      let oldClass = oldVnode.data.class;
      let klass = vnode2.data.class;
      if (!oldClass && !klass)
        return;
      if (oldClass === klass)
        return;
      oldClass = oldClass || {};
      klass = klass || {};
      for (name in oldClass) {
        if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {
          elm.classList.remove(name);
        }
      }
      for (name in klass) {
        cur = klass[name];
        if (cur !== oldClass[name]) {
          elm.classList[cur ? "add" : "remove"](name);
        }
      }
    }
    var classModule2 = { create: updateClass, update: updateClass };
    var CAPS_REGEX = /[A-Z]/g;
    function updateDataset(oldVnode, vnode2) {
      const elm = vnode2.elm;
      let oldDataset = oldVnode.data.dataset;
      let dataset = vnode2.data.dataset;
      let key;
      if (!oldDataset && !dataset)
        return;
      if (oldDataset === dataset)
        return;
      oldDataset = oldDataset || {};
      dataset = dataset || {};
      const d = elm.dataset;
      for (key in oldDataset) {
        if (!dataset[key]) {
          if (d) {
            if (key in d) {
              delete d[key];
            }
          } else {
            elm.removeAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase());
          }
        }
      }
      for (key in dataset) {
        if (oldDataset[key] !== dataset[key]) {
          if (d) {
            d[key] = dataset[key];
          } else {
            elm.setAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase(), dataset[key]);
          }
        }
      }
    }
    var datasetModule = {
      create: updateDataset,
      update: updateDataset
    };
    function invokeHandler(handler, vnode2, event) {
      if (typeof handler === "function") {
        handler.call(vnode2, event, vnode2);
      } else if (typeof handler === "object") {
        for (let i = 0; i < handler.length; i++) {
          invokeHandler(handler[i], vnode2, event);
        }
      }
    }
    function handleEvent(event, vnode2) {
      const name = event.type;
      const on = vnode2.data.on;
      if (on && on[name]) {
        invokeHandler(on[name], vnode2, event);
      }
    }
    function createListener() {
      return function handler(event) {
        handleEvent(event, handler.vnode);
      };
    }
    function updateEventListeners(oldVnode, vnode2) {
      const oldOn = oldVnode.data.on;
      const oldListener = oldVnode.listener;
      const oldElm = oldVnode.elm;
      const on = vnode2 && vnode2.data.on;
      const elm = vnode2 && vnode2.elm;
      let name;
      if (oldOn === on) {
        return;
      }
      if (oldOn && oldListener) {
        if (!on) {
          for (name in oldOn) {
            oldElm.removeEventListener(name, oldListener, false);
          }
        } else {
          for (name in oldOn) {
            if (!on[name]) {
              oldElm.removeEventListener(name, oldListener, false);
            }
          }
        }
      }
      if (on) {
        const listener = vnode2.listener = oldVnode.listener || createListener();
        listener.vnode = vnode2;
        if (!oldOn) {
          for (name in on) {
            elm.addEventListener(name, listener, false);
          }
        } else {
          for (name in on) {
            if (!oldOn[name]) {
              elm.addEventListener(name, listener, false);
            }
          }
        }
      }
    }
    var eventListenersModule2 = {
      create: updateEventListeners,
      update: updateEventListeners,
      destroy: updateEventListeners
    };
    function updateProps(oldVnode, vnode2) {
      let key;
      let cur;
      let old;
      const elm = vnode2.elm;
      let oldProps = oldVnode.data.props;
      let props = vnode2.data.props;
      if (!oldProps && !props)
        return;
      if (oldProps === props)
        return;
      oldProps = oldProps || {};
      props = props || {};
      for (key in props) {
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== "value" || elm[key] !== cur)) {
          elm[key] = cur;
        }
      }
    }
    var propsModule2 = { create: updateProps, update: updateProps };
    var raf = typeof window !== "undefined" && window.requestAnimationFrame.bind(window) || setTimeout;
    var nextFrame = function(fn) {
      raf(function() {
        raf(fn);
      });
    };
    var reflowForced = false;
    function setNextFrame(obj, prop, val) {
      nextFrame(function() {
        obj[prop] = val;
      });
    }
    function updateStyle(oldVnode, vnode2) {
      let cur;
      let name;
      const elm = vnode2.elm;
      let oldStyle = oldVnode.data.style;
      let style = vnode2.data.style;
      if (!oldStyle && !style)
        return;
      if (oldStyle === style)
        return;
      oldStyle = oldStyle || {};
      style = style || {};
      const oldHasDel = "delayed" in oldStyle;
      for (name in oldStyle) {
        if (!style[name]) {
          if (name[0] === "-" && name[1] === "-") {
            elm.style.removeProperty(name);
          } else {
            elm.style[name] = "";
          }
        }
      }
      for (name in style) {
        cur = style[name];
        if (name === "delayed" && style.delayed) {
          for (const name2 in style.delayed) {
            cur = style.delayed[name2];
            if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
              setNextFrame(elm.style, name2, cur);
            }
          }
        } else if (name !== "remove" && cur !== oldStyle[name]) {
          if (name[0] === "-" && name[1] === "-") {
            elm.style.setProperty(name, cur);
          } else {
            elm.style[name] = cur;
          }
        }
      }
    }
    function applyDestroyStyle(vnode2) {
      let style;
      let name;
      const elm = vnode2.elm;
      const s = vnode2.data.style;
      if (!s || !(style = s.destroy))
        return;
      for (name in style) {
        elm.style[name] = style[name];
      }
    }
    function applyRemoveStyle(vnode2, rm) {
      const s = vnode2.data.style;
      if (!s || !s.remove) {
        rm();
        return;
      }
      if (!reflowForced) {
        vnode2.elm.offsetLeft;
        reflowForced = true;
      }
      let name;
      const elm = vnode2.elm;
      let i = 0;
      const style = s.remove;
      let amount = 0;
      const applied = [];
      for (name in style) {
        applied.push(name);
        elm.style[name] = style[name];
      }
      const compStyle = getComputedStyle(elm);
      const props = compStyle["transition-property"].split(", ");
      for (; i < props.length; ++i) {
        if (applied.indexOf(props[i]) !== -1)
          amount++;
      }
      elm.addEventListener("transitionend", function(ev) {
        if (ev.target === elm)
          --amount;
        if (amount === 0)
          rm();
      });
    }
    function forceReflow() {
      reflowForced = false;
    }
    var styleModule2 = {
      pre: forceReflow,
      create: updateStyle,
      update: updateStyle,
      destroy: applyDestroyStyle,
      remove: applyRemoveStyle
    };
    function Fragment(data, ...children) {
      const flatChildren = flattenAndFilter(children, []);
      if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
        return vnode(void 0, void 0, void 0, flatChildren[0].text, void 0);
      } else {
        return vnode(void 0, data !== null && data !== void 0 ? data : {}, flatChildren, void 0, void 0);
      }
    }
    function flattenAndFilter(children, flattened) {
      for (const child of children) {
        if (child !== void 0 && child !== null && child !== false && child !== "") {
          if (Array.isArray(child)) {
            flattenAndFilter(child, flattened);
          } else if (typeof child === "string" || typeof child === "number" || typeof child === "boolean") {
            flattened.push(vnode(void 0, void 0, void 0, String(child), void 0));
          } else {
            flattened.push(child);
          }
        }
      }
      return flattened;
    }
    function jsx(tag, data, ...children) {
      const flatChildren = flattenAndFilter(children, []);
      if (typeof tag === "function") {
        return tag(data, flatChildren);
      } else {
        if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
          return h3(tag, data, flatChildren[0].text);
        } else {
          return h3(tag, data, flatChildren);
        }
      }
    }
    (function(jsx2) {
    })(jsx || (jsx = {}));
    exports.Fragment = Fragment;
    exports.array = array;
    exports.attachTo = attachTo;
    exports.attributesModule = attributesModule2;
    exports.classModule = classModule2;
    exports.datasetModule = datasetModule;
    exports.eventListenersModule = eventListenersModule2;
    exports.fragment = fragment;
    exports.h = h3;
    exports.htmlDomApi = htmlDomApi;
    exports.init = init$1;
    exports.jsx = jsx;
    exports.primitive = primitive;
    exports.propsModule = propsModule2;
    exports.styleModule = styleModule2;
    exports.thunk = thunk;
    exports.toVNode = toVNode2;
    exports.vnode = vnode;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/spargo.ts
var import_snabbdom2 = __toESM(require_snabbdom_cjs());

// src/utils.ts
function valueTruthyInObject(value, object) {
  if (object[value] !== void 0 && typeof object[value] === "function" && object[value]()) {
    return true;
  }
  if (value.substring(0, 1) === "!" && object[value.slice(1)] !== void 0 && !object[value.slice(1)] || value.substring(0, 1) !== "!" && object[value] !== void 0 && object[value]) {
    return true;
  } else if (value.substring(0, 1) === "!" && object[value.slice(1)] === void 0 || value.substring(0, 1) !== "!" && object[value] === void 0) {
    throw new Error(`${value} not found in state`);
  }
  return false;
}
function generateProps(object, element) {
  const attributes = [
    "id",
    "name",
    "style",
    "placeholder",
    "ref",
    "href",
    "src",
    "target",
    "aria-label",
    "disabled",
    "hidden",
    "selected",
    "for",
    "type",
    "max",
    "min",
    "accept",
    "accept-charset",
    "accesskey",
    "action",
    "align",
    "allow",
    "alt",
    "async",
    "autocapitalize",
    "autocomplete",
    "autofocus",
    "autoplay",
    "bgcolor",
    "buffered",
    "capture",
    "charset",
    "checked",
    "cite",
    "code",
    "codebase",
    "color",
    "cols",
    "colspan",
    "content",
    "contenteditable",
    "disabled",
    "draggable"
  ];
  const expandedObject = {};
  attributes.forEach((attr) => {
    const elementAttr = element.getAttribute(attr);
    if (elementAttr !== null) {
      expandedObject[attr] = elementAttr || true;
    }
  });
  return { ...expandedObject, ...object };
}
function generateAttrs(object, element) {
  const attributes = [
    "xmlns",
    "fill",
    "viewBox",
    "stroke-width",
    "stroke",
    "stroke-linecap",
    "stroke-linejoin",
    "d",
    "x1",
    "x2",
    "y1",
    "y2"
  ];
  const expandedObject = {};
  attributes.forEach((attr) => {
    const elementAttr = element.getAttribute(attr);
    if (elementAttr !== null) {
      if (Number.parseFloat(elementAttr)) {
        expandedObject[attr] = Number.parseFloat(elementAttr);
      } else if (Number.parseInt(elementAttr)) {
        expandedObject[attr] = Number.parseInt(elementAttr);
      } else {
        expandedObject[attr] = elementAttr || true;
      }
    }
  });
  return { ...expandedObject, ...object };
}
function retrieveClasses(element, object) {
  const classes = element.getAttribute("class");
  const classAttr = element.getAttribute("@class");
  let customClasses, check = null;
  const classesObject = {};
  if (classAttr) {
    [check, customClasses] = classAttr.split("=>");
    if (customClasses === void 0 && check === void 0) {
      throw new Error("Truth check and classes must be provided when @class is set. Please remove if not needed.");
    } else if (check && customClasses === void 0) {
      throw new Error(`Classes must be provided after the => for truth check ${check}`);
    } else if (check === void 0) {
      throw new Error("A truth check must be provided before the => in @class");
    } else {
      const [ifTrueClasses, ifFalseClasses] = customClasses.split("||");
      if (valueTruthyInObject(check.trim(), object)) {
        customClasses = ifTrueClasses;
      } else {
        customClasses = ifFalseClasses;
      }
    }
  }
  if (classes || customClasses) {
    ((classes || "") + (customClasses ? " " + customClasses : "")).split(" ").filter((classString) => classString.trim() !== "").forEach((classString) => {
      classesObject[classString] = true;
    });
  }
  return classesObject;
}

// src/vdom.ts
var import_snabbdom = __toESM(require_snabbdom_cjs());

// src/masks.ts
var phone = (value) => {
  const input = value.replace(/\D/g, "").substring(0, 10);
  const areaCode = input.substring(0, 3);
  const middle = input.substring(3, 6);
  const last = input.substring(6, 10);
  if (input.length > 6) {
    value = `(${areaCode}) ${middle} - ${last}`;
  } else if (input.length > 3) {
    value = `(${areaCode}) ${middle}`;
  } else if (input.length > 0) {
    value = `(${areaCode}`;
  }
  return value;
};
var currency = (value, args) => {
  const [format, currency2] = (args == null ? void 0 : args.split("|")) || "";
  const strippedValue = value.replace(".", "").replace(",", "").replace(/\D/g, "");
  const float = +strippedValue;
  if (isNaN(float)) {
    throw new Error(`Value provided to currency is not a number: ${value}`);
  }
  return new Intl.NumberFormat(format || "en-US", {
    currency: currency2 || "USD",
    style: "currency"
  }).format(float / 100);
};
var date = (value) => {
  const strippedValue = value.replace(/\D/g, "").slice(0, 10);
  if (strippedValue.length >= 5) {
    return `${strippedValue.slice(0, 2)}/${strippedValue.slice(2, 4)}/${strippedValue.slice(4, 8)}`;
  } else if (strippedValue.length >= 3) {
    return `${strippedValue.slice(0, 2)}/${strippedValue.slice(2)}`;
  }
  return strippedValue;
};
var masks = {
  phone,
  currency,
  date
};
var masks_default = masks;

// src/vdom.ts
var Vdom = class {
  constructor(elements, patch2) {
    this.elements = [];
    this.elements = elements;
    this.patch = patch2;
  }
  // noinspection TypeScriptValidateJSTypes
  /**
   * @description Generate snabbdom VNode's from an Element's children
   * @param children
   * @param object
   * @returns (string | VNode)[]
   * @throws If an input is not synced to a piece of state
   * @throws If a synced value does not exist
   * @throws If a mask does not exist
   */
  generateVNodes(children, object) {
    const ifData = {
      ifIsFalse: false,
      elseIfIsFalse: false,
      elseIfPresent: false
    };
    return Array.from(children).map((child) => {
      const nodeData = {};
      switch (child.nodeType) {
        case 1: {
          return this.generateVNodeForElement(child, ifData, object, nodeData);
        }
        case 3:
          return child.textContent || "";
        default:
          return (0, import_snabbdom.h)(
            child.nodeName,
            nodeData,
            child.childNodes.length > 0 ? this.generateVNodes(child.childNodes, object) : []
          );
      }
    });
  }
  /**
   * @description Prepares the given element to pass through the generateVNodes method
   * @param element
   * @param object
   * @returns void
   * @throws If the provided piece of state to iterate over does not exist
   */
  iterateOverLoops(element, object) {
    Array.from(element.children).forEach((child) => {
      var _a;
      const forCheck = child.getAttribute("@for");
      if (forCheck) {
        const [name, objectKey] = forCheck.split("in");
        if (object[objectKey.trim()] === void 0) {
          throw new Error(`${objectKey.trim()} does not exist in the object.`);
        }
        this.loopNodeCreations(child, object, objectKey, name);
        (_a = child.parentElement) == null ? void 0 : _a.removeAttribute("@for");
        child.remove();
      }
      if (child.children.length > 0) {
        this.iterateOverLoops(child, object);
      }
    });
  }
  /**
   * @description Update the JavaScript state from an update to state and patch the view accordingly via the element
   * @param spargoElementObject
   * @returns void
   * @throws If the associated element is not found in memory
   */
  updateByElement(spargoElementObject) {
    const spargoElement = this.elements.find((element) => {
      return element.object === spargoElementObject;
    });
    if (!spargoElement) {
      throw new Error("Value updated in state, but the associated object could not be found in memory.");
    }
    const pureElement = spargoElement.element.cloneNode(true);
    this.iterateOverLoops(spargoElement.element, spargoElement.object);
    const updatedNodeChildren = this.generateVNodes(
      spargoElement.element.childNodes,
      spargoElement.object
    );
    spargoElement.element = pureElement;
    if (updatedNodeChildren.length > 0 && spargoElement.vNode.sel && spargoElement.vNode.data) {
      spargoElement.vNode.data = generateProps({}, spargoElement.element);
      const updatedNode = (0, import_snabbdom.h)(spargoElement.vNode.sel, spargoElement.vNode.data, updatedNodeChildren);
      this.patch(spargoElement.vNode, updatedNode);
      spargoElement.vNode = updatedNode;
    }
  }
  /*
  * @description Generate nodes for @for
  * @param child
  * @param object
  * @param objectKey
  * @param name
  * @returns void
  */
  loopNodeCreations(child, object, objectKey, name) {
    object[objectKey.trim()].forEach((value) => {
      const newNode = child.cloneNode(true);
      newNode.childNodes.forEach((node) => {
        if (node.nodeType === 1) {
          this.updateLoopElement(node, value, name);
        }
      });
      child.before(newNode);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  updateLoopElement(node, value, name) {
    this.handleLoopTextAttr(node, value, name);
    this.handleLoopHrefAttr(node, value);
    this.handleLoopIfAttr(node, value);
    this.handleLoopClassAttr(node, value);
    if (node.hasChildNodes()) {
      node.childNodes.forEach((node2) => {
        if (node2.nodeType === 1) {
          this.updateLoopElement(node2, value, name);
        }
      });
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleLoopTextAttr(node, value, name) {
    if (node.hasAttribute("@text")) {
      const text = node.getAttribute("@text");
      if (text) {
        if (name.trim() === "_") {
          node.innerText = value[text];
        } else {
          node.innerText = value;
        }
        node.removeAttribute("@text");
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleLoopHrefAttr(node, value) {
    if (node.hasAttribute("@href")) {
      const hrefAttr = node.getAttribute("@href");
      const hrefString = value[hrefAttr];
      if (hrefString === void 0) {
        throw new Error(`${hrefAttr} not found in this iteration.`);
      }
      node.setAttribute("href", hrefString);
      node.removeAttribute("@href");
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleLoopIfAttr(node, value) {
    if (node.hasAttribute("@if")) {
      const ifAttr = node.getAttribute("@if");
      if (!valueTruthyInObject(ifAttr, value)) {
        node.remove();
      } else {
        node.removeAttribute("@if");
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleLoopClassAttr(node, value) {
    if (node.hasAttribute("@class")) {
      const classes = node.getAttribute("class");
      const classAttr = node.getAttribute("@class");
      let customClasses, check;
      [check, customClasses] = classAttr.split("=>");
      if (customClasses === void 0 && check === void 0) {
        throw new Error("Truth check and classes must be provided when @class is set. Please remove if not needed.");
      } else if (check && customClasses === void 0) {
        throw new Error(`Classes must be provided after the => for truth check ${check}`);
      } else if (check === void 0) {
        throw new Error("A truth check must be provided before the => in @class");
      } else {
        const [ifTrueClasses, ifFalseClasses] = customClasses.split("||");
        if (valueTruthyInObject(check.trim(), value)) {
          customClasses = ifTrueClasses;
        } else {
          customClasses = ifFalseClasses;
        }
      }
      if (classes || customClasses) {
        node.setAttribute(
          "class",
          (classes || "") + (customClasses ? " " + customClasses : "")
        );
      }
      node.removeAttribute("@class");
    }
  }
  /*
  * @description Generate a Vnode for an element
  * @param child
  * @param ifData
  * @param object
  * @param nodeData
  * @returns VNode | string
  */
  generateVNodeForElement(child, ifData, object, nodeData) {
    const childElement = child;
    if (this.shouldNotIncludeCheck(childElement, ifData, object)) {
      return "";
    }
    const customHrefAttr = childElement.getAttribute("@href");
    if (customHrefAttr) {
      if (object[customHrefAttr] === void 0) {
        throw new Error(`Could not find ${customHrefAttr} in the object.`);
      } else {
        childElement.setAttribute("href", object[customHrefAttr]);
      }
    }
    nodeData.props = generateProps({}, childElement);
    nodeData.attrs = generateAttrs({}, childElement);
    nodeData.class = retrieveClasses(childElement, object);
    switch (childElement.nodeName) {
      case "INPUT": {
        const props = this.generateInputProps(childElement, object);
        const updateState = (e) => {
          this.updateState(e);
        };
        nodeData.props = generateProps({ ...props, ...nodeData.props }, childElement);
        nodeData.on = { input: updateState };
        return this.generateVNode(child, childElement, object, nodeData);
      }
      case "BUTTON": {
        this.attachListenersToButton(childElement, object, nodeData);
        return this.generateVNode(child, childElement, object, nodeData);
      }
      default: {
        return this.generateVNode(child, childElement, object, nodeData);
      }
    }
  }
  /*
  * @description Attach listeners to a button
  * @param childElement
  * @param object
  * @param nodeData - possibly mutated
  * @returns void
  */
  attachListenersToButton(childElement, object, nodeData) {
    const click = childElement.getAttribute("@click");
    if (click) {
      const method = object[click];
      if (typeof method !== "function") {
        const methodWithParens = object[click.slice(0, -2)];
        if (typeof methodWithParens !== "function") {
          throw new Error(`${click} was not found as a method`);
        }
      }
      const runFunction = (e) => {
        let index = null;
        if (e.target) {
          const target = e.target;
          index = this.elements.findIndex((element) => element.id === this.findSpargoParentNodeLocalName(target.parentNode));
          this.elements[index].object[method ? click : click.slice(0, -2)]();
        }
      };
      nodeData.on = { click: runFunction };
    }
  }
  /*
  * @description Generate custom props for an input
  * @param childElement
  * @param object
  * @returns {
      value: string | null,
      sync: string | null,
      mask: string | null,
      maskArgs: string | null,
  }
  */
  generateInputProps(childElement, object) {
    var _a;
    const sync = childElement.getAttribute("@sync");
    if (!sync) {
      throw new Error(`It is expected that all input's are synced to a piece of data.`);
    }
    const value = object[sync];
    if (value === void 0 && !((_a = Object.getOwnPropertyDescriptor(object, sync)) == null ? void 0 : _a.set)) {
      throw new Error(`${sync} does not exist.`);
    }
    const mask = childElement.getAttribute("@mask");
    if (mask && masks_default[mask] === void 0) {
      throw new Error(`The @mask ${mask} does not exist.`);
    }
    const maskArgs = childElement.getAttribute("@mask-args");
    return { value, sync, mask, maskArgs };
  }
  /**
   * @description Checks if the provided element should not be included in the dom
   * @param childElement
   * @param ifData
   * @param object
   * @returns boolean
   */
  shouldNotIncludeCheck(childElement, ifData, object) {
    const ifCheck = childElement.getAttribute("@if");
    if (ifCheck && !valueTruthyInObject(ifCheck, object)) {
      ifData.ifIsFalse = true;
      return true;
    }
    const elseIfCheck = childElement.getAttribute("@elseif");
    const elseCheck = childElement.getAttribute("@else") !== null;
    if (elseIfCheck) {
      ifData.elseIfPresent = true;
    }
    if (!elseIfCheck && !elseCheck) {
      ifData.ifIsFalse = false;
      ifData.elseIfIsFalse = false;
      ifData.elseIfPresent = false;
    }
    if (!ifData.ifIsFalse && elseIfCheck) {
      return true;
    }
    if (elseIfCheck && !valueTruthyInObject(elseIfCheck, object)) {
      ifData.elseIfIsFalse = true;
      return true;
    }
    if ((!ifData.ifIsFalse || ifData.elseIfPresent && !ifData.elseIfIsFalse) && elseCheck) {
      return true;
    } else if (elseCheck) {
      ifData.ifIsFalse = false;
      ifData.elseIfIsFalse = false;
      ifData.elseIfPresent = false;
    }
    return false;
  }
  /**
   * @description Generate a snabbdom vnode
   * @param child
   * @param childElement
   * @param object
   * @param nodeData
   * @returns VNode
   */
  generateVNode(child, childElement, object, nodeData) {
    const textNode = this.textNode(childElement, object, nodeData);
    if (textNode) {
      return textNode;
    }
    const nodeWithTextContent = this.nodeWithTextContent(childElement, nodeData);
    if (nodeWithTextContent) {
      return nodeWithTextContent;
    }
    return (0, import_snabbdom.h)(
      child.nodeName,
      nodeData,
      child.childNodes.length > 0 ? this.generateVNodes(child.childNodes, object) : []
    );
  }
  /**
   * @description Will generate a node with text content
   * @param childElement
   * @param nodeData
   * @returns VNode | undefined
   */
  nodeWithTextContent(childElement, nodeData) {
    var _a;
    if (((_a = childElement.textContent) == null ? void 0 : _a.trim()) !== "" && childElement.children.length === 0) {
      nodeData.props = generateProps({ ...nodeData.props }, childElement);
      return (0, import_snabbdom.h)(childElement.nodeName, nodeData, childElement.textContent);
    }
  }
  /**
   * @description Will generate a text node if applicable
   * @param childElement
   * @param object
   * @param nodeData
   * @returns VNode | undefined
   * @throws If the associated text value (if it is set) does not exist in the object
   */
  textNode(childElement, object, nodeData) {
    const textAttribute = childElement.getAttribute("@text");
    if (textAttribute) {
      if (object[textAttribute] === void 0) {
        throw new Error(`${textAttribute} does not exist in the object.`);
      }
      nodeData.props = generateProps({ text: textAttribute, ...nodeData.props }, childElement);
      return (0, import_snabbdom.h)(childElement.nodeName, nodeData, object[textAttribute]);
    }
  }
  /**
   * @description Update the JavaScript state from an event and patch the view accordingly
   * @param e
   * @returns void
   * @throws If the associated element is not found in memory
   */
  updateState(e) {
    if (e.target) {
      const target = e.target;
      const index = this.elements.findIndex(
        (element2) => element2.id === this.findSpargoParentNodeLocalName(target.parentNode)
      );
      if (index < 0) {
        throw new Error(`Element with id of ${target.parentNode.localName} not found in memory`);
      }
      const element = this.elements[index];
      this.retrieveNodeChildren(element.vNode.children, element, e);
    }
  }
  /**
   * @description Hunt down the snabbdom .sel for the given element
   * @param element
   * @returns string
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  findSpargoParentNodeLocalName(element) {
    if (element.localName.includes("spargo-")) {
      return element.localName;
    } else if (element.parentNode && element.parentNode.localName.includes("spargo-")) {
      return element.parentNode.localName;
    } else {
      return this.findSpargoParentNodeLocalName(element.parentNode);
    }
  }
  /**
   * @description Generate new snabbdom nodes with updated values and update any necessary JavaScript state
   * @param nodes
   * @param element
   * @param e
   * @returns void
   */
  retrieveNodeChildren(nodes, element, e) {
    const target = e.target;
    const object = element.object;
    nodes == null ? void 0 : nodes.map((childNode) => {
      if (typeof childNode !== "string" && childNode.children && childNode.children.length > 0) {
        this.retrieveNodeChildren(childNode.children, element, e);
      } else if (typeof childNode !== "string" && childNode.data && childNode.data.props && childNode.data.props["sync"] && childNode.data.props["sync"] === target.sync) {
        if (childNode.data.props["mask"]) {
          if (childNode.data.props["maskArgs"]) {
            object[childNode.data.props["sync"]] = masks_default[childNode.data.props["mask"]](target.value, childNode.data.props["maskArgs"]);
          } else {
            object[childNode.data.props["sync"]] = masks_default[childNode.data.props["mask"]](target.value);
          }
          target.value = object[childNode.data.props["sync"]];
        } else {
          object[childNode.data.props["sync"]] = target.value;
        }
      }
    });
  }
};

// src/spargo.ts
var patch = (0, import_snabbdom2.init)([
  import_snabbdom2.classModule,
  import_snabbdom2.propsModule,
  import_snabbdom2.styleModule,
  import_snabbdom2.attributesModule,
  import_snabbdom2.eventListenersModule
]);
var Spargo = class {
  constructor() {
    this.elements = [];
    this.vdom = new Vdom([], patch);
    window.addEventListener("DOMContentLoaded", () => {
      this.vdom = new Vdom(this.elements, patch);
      this.initialize();
    });
  }
  /**
   * @returns void
   */
  initialize() {
    const elements = document.querySelectorAll("[ignite]");
    elements.forEach((element) => {
      this.createElement(element);
    });
  }
  /**
   * @description Create a new element
   * @param element
   * @returns void
   * @throws Error if the provided element does not have an associated method
   */
  createElement(element) {
    if (element.getAttribute("spargo-id")) {
      return;
    }
    const object = window[element.getAttribute("ignite")]();
    if (!object) {
      throw new Error(`${element.getAttribute("ignite")} does not exist as a method on the page.`);
    }
    const id = `spargo-${crypto.randomUUID()}`;
    const pureElement = element.cloneNode(true);
    this.vdom.iterateOverLoops(element, object);
    const node = (0, import_snabbdom2.h)(
      id,
      { class: retrieveClasses(element, object) },
      this.vdom.generateVNodes(element.childNodes, object)
    );
    patch((0, import_snabbdom2.toVNode)(element), node);
    const objectProxy = new Proxy(object, {
      set: (object2, key, value, proxy) => {
        if (typeof key === "string") {
          object2[key] = value;
        }
        this.vdom.updateByElement(proxy);
        return true;
      }
    });
    this.elements.push({ id, vNode: node, object: objectProxy, element: pureElement });
    if (typeof objectProxy.ignited === "function") {
      objectProxy.ignited();
    }
  }
};

// src/index.ts
var src_default = Spargo;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
